# Contoso Order Processing Platform  
## Cloud-Native Asynchronous Architecture (Greenfield Case Study)

---

## 1. Overview

Contoso wants to build a **cloud-native, highly scalable order processing platform** designed for **high-throughput OLTP workloads** and **real-time user feedback**, while maintaining strong decoupling between frontend and backend systems.

This project is a **greenfield reference architecture**, intentionally designed to reflect **real-world enterprise patterns** rather than simplified demos.

The system is:
- Fully asynchronous
- Event-driven
- Horizontally scalable
- Designed for high availability
- Built using Azure managed services and Kubernetes

This case study is intended to be used as:
- Technical portfolio material
- Architecture discussion artifact in interviews
- Reference design for cloud-native systems

---

## 2. Functional Requirements

### Order Submission
- Users submit orders via a **Single Page Application (SPA)**.
- Order submission must be **non-blocking**.
- The frontend must never wait for backend processing completion.

### Order Processing
- Orders are processed asynchronously.
- FIFO semantics are required.
- The system must tolerate retries and duplicate message delivery.

### User Notification
- Users must be notified **in real time** when:
  - An order has completed processing.
- Notifications are delivered via **WebSockets**.

---

## 3. Non-Functional Requirements

- High availability and fault tolerance
- Horizontal scalability
- Loose coupling between components
- Event-driven communication
- Strong consistency for transactional data
- Secure by default
- Clear separation of responsibilities
- Production-ready design (not demo-oriented)

---

## 4. High-Level Architecture

### Conceptual Flow

1. The SPA establishes a WebSocket connection with the backend.
2. The user submits an order via HTTP.
3. A **CorrelationId** is generated at the API boundary.
4. The request is published to a FIFO queue.
5. Backend processors consume and process the order asynchronously.
6. The order is persisted in the database, generating a database-native `OrderId`.
7. An event signaling completion is published.
8. A notification service resolves the WebSocket session and pushes a real-time update to the user.

---

## 5. Identity and Correlation Model

This architecture intentionally separates **technical correlation** from **business identity**:

| Concept | Purpose | Generated By |
|------|--------|-------------|
| CorrelationId | Async workflow tracking | Order Accept API |
| OrderId | Business identifier | SQL Database |

This separation enables:
- True asynchronous processing
- Database independence at ingestion time
- Clean traceability across distributed components

---

## 6. Core Components

### Frontend
- SPA (implementation out of scope)
- Maintains a persistent WebSocket connection

### API Gateway
- Azure API Management
- Validates JWT tokens
- Extracts user identity from claims
- Forwards authenticated requests to AKS
- Contains **no business logic**

### Kubernetes (AKS)

A single AKS cluster is shown in the diagram for **conceptual clarity**.

> **Note:**  
> In a production-grade deployment, this architecture supports **zonal or multi-cluster setups**.  
> Cluster replication is intentionally omitted from the diagram to avoid visual complexity and to focus on logical architecture.

Workloads deployed in AKS:
- Order Accept API
- Order Processor
- Real-Time Notification Service (WebSocket server)

All services are stateless and horizontally scalable.

### Messaging
- Azure Service Bus Queues
- FIFO semantics
- At-least-once delivery
- Built-in retries and dead-lettering

### Data Storage
- Azure SQL Database (Business Critical tier)
- Database-generated primary keys
- Strong consistency guarantees

### Redis
- Azure Cache for Redis
- Acts as a **short-lived correlation and session registry**
- Maps `CorrelationId` to WebSocket connection metadata
- TTL-based cleanup

---

## 7. Real-Time Notification Design

- WebSocket connections are terminated by a dedicated notification service.
- Redis is used to resolve:
  - Which user
  - Which connection
- Redis does **not** push messages.
- WebSocket messages are sent directly from the notification service to the SPA.

---

